6.1 組件(STL Components):關鍵的三個組件
    1.容器(Container):用來管理 物件的群集
    2.迭代器(Iterator):
        用來訪問群集中的元素，用法類似於pointer，可以視作一種smart pointer。
        透過operator++前往下一個元素，透過operator*來獲取存取當前物件。
    3.演算法(Algorithm):用來處理群集中的元素，例如:搜尋、排序、修改、使用
    
    STL 提供更加泛型的組件，可以藉由 適配器(adapter)與函式物件(function object)來規範或製作 演算法
6.2 容器(Container):分成三大類
    1.序列式容器(Sequence containers):每個元素有確切的位置，取決於插入的時間或地點，與元素值無關。
        通常用 array 或 linked-list 實作
        STL提供以下template class
        1.vector:定義在<vector>中，使用dynamic-array管理
            常用函數:push_back()與size()
            優點:隨機訪問快、允許下標存取、後方插入快
            缺點:非後方的插入或刪除 費時
        2.deque:定義在<deque>中，全名為double-ended queue 同樣使用dynamic-array管理
            常用函數:push_back()、push_front()
            優點:隨機訪問快、允許下標存取、前方與後方插入快
            缺點:非前方與非後方 插入或刪除 費時
        3.list:有兩種定義 <list> <forward_list> 使用doubly linked list實作
            list的功能強大於forward_list
            常用函數:push_back()、front()、pop_front()
            優點:在任意位置插入或刪除非常快
            缺點:不提供隨機訪問
    2.關聯式容器(Associative containers):每個元素都已被排序，是透過元素的 key or value 或透過特定的演算法來排序。
        通常用 binary tree 實作
    3.不定序容器(Unordered containers):只在意 特定元素是否存在 在於群集中，而不在乎 位置與排序
        通常用來實作 hash table 實作
    [思考]關聯式容器因為會自動完成排序過程，因此在 搜尋 動作時 時間複雜度是較低的(對數級別)，可以直接進行binary search
    
